/**
 * Search
 *
 * Code for searching for dex information
 *
 *
 * @author Guangcong Luo <guangcongluo@gmail.com>
 * @license MIT
 *//** ID, SearchType, index (if alias), offset (if offset alias) */let e,t=[];function s(e,t){for(let s in e.abilities)if(toID(e.abilities[s])==toID(t))return!0;return!1}/**

/**
 * Backend for search UIs.
 */class r{static #e=this.typeTable={pokemon:1,type:2,tier:3,move:4,item:5,ability:6,egggroup:7,category:8,article:9};static #t=this.typeName={pokemon:"Pok&eacute;mon",type:"Type",tier:"Tiers",move:"Moves",item:"Items",ability:"Abilities",egggroup:"Egg group",category:"Category",article:"Article"};constructor(s="",r="",l=""){let a;this.query="",this.typedSearch=null,this.results=null,this.exactMatch=!1,this.firstPokemonColumn="Number",/**
   * Column to sort by. Default is `null`, a smart sort determined by how good
   * things are according to the base filters, falling back to dex number (for
   * Pokemon) and name (for everything else).
   */this.sortCol=null,this.reverseSort=!1,/**
   * Filters for the search result. Does not include the two base filters
   * (format and species).
   */this.filters=null,(a=(a=(a=(a=(a=(a=(a=(a=[]).concat(Object.keys(BattlePokedex).map(e=>e+" pokemon"))).concat(Object.keys(BattleMovedex).map(e=>e+" move"))).concat(Object.keys(BattleItems).map(e=>e+" item"))).concat(Object.keys(BattleAbilities).map(e=>e+" ability"))).concat(Object.keys(BattleTypeChart).map(e=>toID(e)+" type"))).concat(["physical","special","status"].map(e=>toID(e)+" category"))).concat(["monster","water1","bug","flying","field","fairy","grass","humanlike","water3","mineral","amorphous","water2","ditto","dragon","undiscovered"].map(e=>toID(e)+" egggroup"))).sort(),// manually rearrange
a[a.indexOf("grass type")]="grass egggroup",a[a.indexOf("grass egggroup")]="grass type",a[a.indexOf("fairy type")]="fairy egggroup",a[a.indexOf("fairy egggroup")]="fairy type",a[a.indexOf("flying type")]="flying egggroup",a[a.indexOf("flying egggroup")]="flying type",a[a.indexOf("dragon type")]="dragon egggroup",a[a.indexOf("dragon egggroup")]="dragon type",a[a.indexOf("bug type")]="bug egggroup",a[a.indexOf("bug egggroup")]="bug type",a[a.indexOf("psychic type")]="psychic move",a[a.indexOf("psychic move")]="psychic type",getID(BattlePokedex,"ditto")&&(a[a.indexOf("ditto pokemon")]="ditto egggroup",a[a.indexOf("ditto egggroup")]="ditto pokemon"),e=(t=a.map(e=>{let t=e.split(" ");return t.length>3&&(t[3]=Number(t[3]),t[2]=a.indexOf(t[2]+" "+t[1])),t})).map((e,t)=>{let s=e[0],r="";switch(e[1]){case"pokemon":r=getID(BattlePokedex,s).name??"";break;case"move":r=getID(BattleMovedex,s).name??"";break;case"item":r=getID(BattleItems,s).name??"";break;case"ability":r=getID(BattleAbilities,s).name??""}let l="",a=0;for(let e=0,t=0;e<s.length;e++,t++){for(;!/[a-zA-Z0-9]/.test(r[t]);)t++,a++;l+=a}return a?l:""}),this.setType(s,r,l)}getTypedSearch(e,t="",s){if(!e)return null;switch(e){case"pokemon":return new a("pokemon",t,s);case"item":return new o("item",t,s);case"move":return new n("move",t,s);case"ability":return new i("ability",t,s);case"type":return new u("type",t,s);case"category":return new h("category",t,s)}return null}find(e){return e=toID(e),(this.query!==e||!this.results)&&(this.query=e,e?this.results=this.textSearch(e):this.results=this.typedSearch?.getResults(this.filters,this.sortCol,this.reverseSort)||[],!0)}setType(e,t="",s){// invalidate caches
this.results=null,e!==this.typedSearch?.searchType&&(this.filters=null,this.sortCol=null),this.typedSearch=this.getTypedSearch(e,t,s)}addFilter(e){if(!this.typedSearch)return!1;let[t]=e;if("pokemon"===this.typedSearch.searchType){if(t===this.sortCol&&(this.sortCol=null),!["type","move","ability","egggroup","tier"].includes(t))return!1;for(let s of("move"===t&&(e[1]=toID(e[1])),this.filters||(this.filters=[]),this.results=null,this.filters))if(s[0]===t&&s[1]===e[1])return!0;return this.filters.push(e),!0}return"move"===this.typedSearch.searchType&&(t===this.sortCol&&(this.sortCol=null),!!["type","category","pokemon"].includes(t)&&("pokemon"===t&&(e[1]=toID(e[1])),this.filters||(this.filters=[]),this.filters.push(e),this.results=null,!0))}removeFilter(e){if(!this.filters)return!1;if(e){let t=e.join(":"),s=null;// delete specific filter
for(let e=0;e<this.filters.length;e++)if(t===this.filters[e].join(":")){s=this.filters[e],this.filters.splice(e,1);break}if(!s)return!1}else this.filters.pop();return this.filters.length||(this.filters=null),this.results=null,!0}toggleSort(e){this.sortCol===e?this.reverseSort?(this.sortCol=null,this.reverseSort=!1):this.reverseSort=!0:(this.sortCol=e,this.reverseSort=!1),this.results=null}filterLabel(e){return this.typedSearch&&this.typedSearch.searchType!==e?"Filter":null}illegalLabel(e){return this.typedSearch?.illegalReasons?.[e]||null}textSearch(s){s=toID(s),this.exactMatch=!1;let l=this.typedSearch?.searchType||"",a=l?r.typeTable[l]:-1,i="";"type"===s.slice(-4)&&s.slice(0,-4) in BattleTypeChart&&(s=s.slice(0,-4),i="type");// i represents the location of the search index we're looking at
let o=r.getClosest(s);this.exactMatch=t[o][0]===s;// Even with output buffer buckets, we make multiple passes through
// the search index. searchPasses is a queue of which pass we're on:
// [passType, i, query]
// By doing an alias pass after the normal pass, we ensure that
// mid-word matches only display after start matches.
let n="",h=[["normal",o,s]];// If there are no matches starting with query: Do a fuzzy match pass
// Fuzzy matches will still be shown after alias matches
if(s.length>1&&h.push(["alias",o,s]),!this.exactMatch&&t[o][0].substr(0,s.length)!==s){// No results start with this. Do a fuzzy match pass.
let e=s.length-1;for(!o&&o++;e&&t[o][0].substr(0,e)!==s.substr(0,e)&&t[o-1][0].substr(0,e)!==s.substr(0,e);)e--;let r=s.substr(0,e);for(;o>=1&&t[o-1][0].substr(0,e)===r;)o--;h.push(["fuzzy",o,""])}// We split the output buffers into 8 buckets.
// Bucket 0 is usually unused, and buckets 1-7 represent
// pokemon, types, moves, etc (see typeTable).
// When we're done, the buffers are concatenated together to form
// our results, with each buffer getting its own header, unlike
// multiple-pass results, which have no header.
// Notes:
// - if we have a searchType, that searchType's buffer will be on top
let u=[[],[],[],[],[],[],[],[],[],[]],c=-1,p=0,g=!1,f=null,y=[0,1,2,5,4,3,6,7,8],d=this.typedSearch?.illegalReasons;// We aren't actually looping through the entirety of the searchIndex
for(o=0;o<t.length;o++){if(!n){let e=h.shift();if(!e)break;n=e[0],o=e[1],s=e[2]}let b=t[o],m=b[0],k=b[1];if(!m)break;if("fuzzy"===n){// fuzzy match pass; stop after 2 results
if(p>=2){n="";continue}g=!0}else if("exact"===n){if(p>=1){n="";continue}}else if(m.substr(0,s.length)!==s){// regular pass, time to move onto our next match
n="";continue}if(b.length>2)// alias entry
{if("alias"!==n)continue}else // normal entry
if("alias"===n)continue;let v=r.typeTable[k];// For performance, with a query length of 1, we only fill the first bucket
if(1===s.length&&v!==(l?a:1)||"pokemon"===l&&(5===v||v>7)||"move"===l&&(8!==v&&v>4||3===v)||"move"===l&&d&&1===v||("ability"===l||"item"===l)&&v!==a||"type"===i&&2!==v||("megax"===m||"megay"===m)&&"mega".startsWith(s))continue;let x=0,B=0;if("alias"===n){// alias entry
// [aliasid, type, originalid, matchStart, originalindex]
x=b[3];let r=b[2];x&&(B=x+s.length,x+=(e[r][x]||"0").charCodeAt(0)-48,B+=(e[r][B-1]||"0").charCodeAt(0)-48),m=t[r][0]}else(B=s.length)&&(B+=(e[o][B-1]||"0").charCodeAt(0)-48);l&&a!==v&&(!f||y[v]<y[f[2]])&&(f=[k,m,v]),c<0&&a<2&&"alias"===n&&!u[1].length&&u[2].length&&(c=2),d&&v===a?(u[v].length||u[0].length||(u[0]=[["header",r.typeName[k]]]),m in d||(v=0)):u[v].length||(u[v]=[["header",r.typeName[k]]]);// don't match duplicate aliases
let R="alias"===n&&u[v].length;(!R||u[v][R-1][1]!==m)&&(u[v].push([k,m,x,B]),p++)}let b=[];return g&&(b=[["html","<em>No exact match found. The closest matches alphabetically are:</em>"]]),c>=0&&(b=b.concat(u[c]),u[c]=[]),a>=0&&(b=(b=b.concat(u[0])).concat(u[a]),u[a]=[],u[0]=[]),f&&p<20&&u.push(this.instafilter(l,f[0],f[1])),this.results=Array.prototype.concat.apply(b,u),this.results??[]}instafilter(e,t,r){let l=[],a=[],i=this.typedSearch?.illegalReasons;if("pokemon"===e)switch(t){case"type":let o=r.charAt(0).toUpperCase()+r.slice(1);for(let e in l.push(["header",`${o}-type Pok&eacute;mon`]),BattlePokedex)BattlePokedex[e].types&&BattlePokedex[e].types.includes(o)&&(i&&e in i?a:l).push(["pokemon",e]);break;case"ability":let n=getID(BattleAbilities,r).name;for(let e in l.push(["header",`${n} Pok&eacute;mon`]),BattlePokedex)BattlePokedex[e].abilities&&s(BattlePokedex[e],n)&&(i&&e in i?a:l).push(["pokemon",e])}else if("move"===e)switch(t){case"type":let h=r.charAt(0).toUpperCase()+r.slice(1);for(let e in l.push(["header",`${h}-type moves`]),BattleMovedex)BattleMovedex[e].type===h&&(i&&e in i?a:l).push(["move",e]);break;case"category":let u=r.charAt(0).toUpperCase()+r.slice(1);for(let e in l.push(["header",`${u} moves`]),BattleMovedex)BattleMovedex[e].category===u&&(i&&e in i?a:l).push(["move",e])}return[...l,...a]}static getClosest(e){// binary search through the index!
let s=0,r=t.length-1;for(;r>s;){let l=Math.floor((r-s)/2+s);if(t[l][0]===e&&(0===l||t[l-1][0]!==e))return l;t[l][0]<e?s=l+1:r=l-1}return s>=t.length-1?s=t.length-1:t[s+1][0]&&t[s][0]<e&&s++,s&&t[s-1][0]===e&&s--,s}}class l{constructor(e,t="",s=""){if(/**
   * `species` is the second of two base filters. It constrains results to
   * things that species can use, and affects the default sort.
   */this.species="",/**
   * `set` is a pseudo-base filter; it has minor effects on move sorting.
   * (Abilities/items can affect what moves are sorted as usable.)
   */this.set=null,/**
   * Cached copy of what the results list would be with only base filters
   * (i.e. with an empty `query` and `filters`)
   */this.baseResults=null,/**
   * Cached copy of all results not in `baseResults` - mostly in case a user
   * is wondering why a specific result isn't showing up.
   */this.baseIllegalResults=null,this.illegalReasons=null,this.results=null,this.sortRow=null,this.searchType=e,this.baseResults=null,this.baseIllegalResults=null,this.species="",this.set=null,"string"==typeof s?s&&(this.species=s):(this.set=s,this.species=toID(this.set.species)),!e||!this.set)return}getResults(e,t,s){let r,l;if("type"===t)return[this.sortRow,...u.prototype.getDefaultResults.call(this)];if("category"===t)return[this.sortRow,...h.prototype.getDefaultResults.call(this)];if("ability"===t)return[this.sortRow,...i.prototype.getDefaultResults.call(this)];if(this.baseResults||(this.baseResults=this.getBaseResults()),!this.baseIllegalResults){let e={};for(let[t,s]of this.baseResults)t===this.searchType&&(e[s]=1);for(let t in this.baseIllegalResults=[],this.illegalReasons={},this.getTable())t in e||(this.baseIllegalResults.push([this.searchType,t]),this.illegalReasons[t]="Illegal")}if(e){for(let t of(r=[],l=[],this.baseResults))this.filter(t,e)&&(r.length&&"header"===t[0]&&"header"===r[r.length-1][0]?r[r.length-1]=t:r.push(t));for(let t of(r.length&&"header"===r[r.length-1][0]&&r.pop(),this.baseIllegalResults))this.filter(t,e)&&l.push(t)}else r=[...this.baseResults],l=null;return t&&(r=r.filter(([e])=>e===this.searchType),r=this.sort(r,t,s),l&&(l=l.filter(([e])=>e===this.searchType),l=this.sort(l,t,s))),this.sortRow&&(r=[this.sortRow,...r]),l&&l.length&&(r=[...r,["header","Illegal results"],...l]),r}}class a extends l{filter(e,t){if(!t||"pokemon"!==e[0])return!0;let r=getID(BattlePokedex,e[1]);for(let[e,l]of t)switch(e){case"type":if(r.types.every(e=>e!=l))return!1;break;case"move":if(!canLearn(r.id,l))return!1;break;case"ability":if(!s(r,l))return!1;break;case"egggroup":if(r.eggGroups.every(e=>e!=l))return!1}return!0}getTable(){return BattlePokedex}getDefaultResults(){let e=[];for(let t in BattlePokedex){switch(t){case"bulbasaur":e.push(["header","Generation 1"]);break;case"chikorita":e.push(["header","Generation 2"]);break;case"treecko":e.push(["header","Generation 3"]);break;case"turtwig":e.push(["header","Generation 4"]);break;case"victini":e.push(["header","Generation 5"]);break;case"chespin":e.push(["header","Generation 6"]);break;case"rowlet":e.push(["header","Generation 7"]);break;case"grookey":e.push(["header","Generation 8"]);break;case"sprigatito":e.push(["header","Generation 9"]);break;case"missingno":e.push(["header","Glitch"]);break;case"syclar":e.push(["header","CAP"]);break;case"pikachucosplay":continue}e.push(["pokemon",t])}return e}getBaseResults(){return this.getDefaultResults()}sort(e,t,s){let r=s?-1:1;if(["hp","atk","def","spa","spd","spe"].includes(t))return e.sort(([e,s],[l,a])=>{let i=getID(BattlePokedex,s).baseStats[t],o=getID(BattlePokedex,a).baseStats[t];return(o-i)*r});if("bst"===t)return e.sort(([e,t],[s,l])=>{let a=getID(BattlePokedex,t).baseStats,i=getID(BattlePokedex,l).baseStats,o=a.hp+a.atk+a.def+a.spa+a.spd+a.spe,n=i.hp+i.atk+i.def+i.spa+i.spd+i.spe;return(n-o)*r});if("name"===t)return e.sort(([e,t],[s,l])=>(t<l?-1:t>l?1:0)*r);throw Error("invalid sortcol")}constructor(...e){super(...e),this.sortRow=["sortpokemon",""]}}class i extends l{getTable(){return BattleAbilities}getDefaultResults(){let e=[];for(let t in BattleAbilities)e.push(["ability",t]);return e}getBaseResults(){return this.getDefaultResults()}filter(e,t){if(!t||"ability"!==e[0])return!0;let r=getID(BattleAbilities,e[1]);for(let[e,l]of t)if("pokemon"===e&&!s(getID(BattlePokedex,l),r.name))return!1;return!0}sort(e,t,s){throw Error("invalid sortcol")}}class o extends l{getTable(){return BattleItems}getDefaultResults(){let e=[];for(let t in e.push(["header","Items"]),BattleItems)e.push(["item",t]);return e}getBaseResults(){return this.getDefaultResults()}filter(e,t){throw Error("invalid filter")}sort(e,t,s){throw Error("invalid sortcol")}}class n extends l{getTable(){return BattleMovedex}getDefaultResults(){let e=[];for(let t in e.push(["header","Moves"]),BattleMovedex)e.push(["move",t]);return e}getBaseResults(){return this.getDefaultResults()}filter(e,t){if(!t||"move"!==e[0])return!0;let s=getID(BattleMovedex,e[1]);for(let[e,r]of t)switch(e){case"type":if(s.type!==r)return!1;break;case"category":if(s.category!==r)return!1;break;case"pokemon":if(!canLearn(r,s.id))return!1}return!0}sort(e,t,s){let r=s?-1:1;switch(t){case"power":let l={return:102,frustration:102,spitup:300,trumpcard:200,naturalgift:80,grassknot:120,lowkick:120,gyroball:150,electroball:150,flail:200,reversal:200,present:120,wringout:120,crushgrip:120,heatcrash:120,heavyslam:120,fling:130,magnitude:150,beatup:24,punishment:1020,psywave:1250,nightshade:1200,seismictoss:1200,dragonrage:1140,sonicboom:1120,superfang:1350,endeavor:1399,sheercold:1501,fissure:1500,horndrill:1500,guillotine:1500};return e.sort(([e,t],[s,a])=>{let i=getID(BattleMovedex,t),o=getID(BattleMovedex,a),n=i.basePower||l[t]||("Status"===i.category?-1:1400);return((o.basePower||l[a]||("Status"===o.category?-1:1400))-n)*r});case"accuracy":return e.sort(([e,t],[s,l])=>{let a=getID(BattleMovedex,t).accuracy||0,i=getID(BattleMovedex,l).accuracy||0;return!0===a&&(a=101),!0===i&&(i=101),(i-a)*r});case"pp":return e.sort(([e,t],[s,l])=>{let a=getID(BattleMovedex,t).pp||0;return((getID(BattleMovedex,l).pp||0)-a)*r});case"name":return e.sort(([e,t],[s,l])=>(t<l?-1:t>l?1:0)*r)}throw Error("invalid sortcol")}constructor(...e){super(...e),this.sortRow=["sortmove",""]}}class h extends l{getTable(){return{physical:1,special:1,status:1}}getDefaultResults(){return[["category","physical"],["category","special"],["category","status"]]}getBaseResults(){return this.getDefaultResults()}filter(e,t){throw Error("invalid filter")}sort(e,t,s){throw Error("invalid sortcol")}}class u extends l{getTable(){return BattleTypeChart}getDefaultResults(){let e=[];for(let t in BattleTypeChart)e.push(["type",t]);return e}getBaseResults(){return this.getDefaultResults()}filter(e,t){throw Error("invalid filter")}sort(e,t,s){throw Error("invalid sortcol")}}window.DexSearch=r;//# sourceMappingURL=index.5f4c8433.js.map

//# sourceMappingURL=index.5f4c8433.js.map
