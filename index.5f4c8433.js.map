{"mappings":"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","sources":["<anon>","ts/battle-dex-search.ts"],"sourcesContent":["/**\n * Search\n *\n * Code for searching for dex information\n *\n *\n * @author Guangcong Luo <guangcongluo@gmail.com>\n * @license MIT\n */ /** ID, SearchType, index (if alias), offset (if offset alias) */ let $978dcbb073010154$var$BattleSearchIndex = [];\nlet $978dcbb073010154$var$BattleSearchIndexOffset;\nfunction $978dcbb073010154$var$hasAbility(pokemon, ability) {\n    for(let key in pokemon.abilities){\n        if (toID(pokemon.abilities[key]) == toID(ability)) return true;\n    }\n    return false;\n}\nfunction $978dcbb073010154$var$generateSearchIndex() {\n    let index = [];\n    index = index.concat(Object.keys(BattlePokedex).map((x)=>x + \" pokemon\"));\n    index = index.concat(Object.keys(BattleMovedex).map((x)=>x + \" move\"));\n    index = index.concat(Object.keys(BattleItems).map((x)=>x + \" item\"));\n    index = index.concat(Object.keys(BattleAbilities).map((x)=>x + \" ability\"));\n    index = index.concat(Object.keys(BattleTypeChart).map((x)=>toID(x) + \" type\"));\n    index = index.concat([\n        \"physical\",\n        \"special\",\n        \"status\"\n    ].map((x)=>toID(x) + \" category\"));\n    index = index.concat([\n        \"monster\",\n        \"water1\",\n        \"bug\",\n        \"flying\",\n        \"field\",\n        \"fairy\",\n        \"grass\",\n        \"humanlike\",\n        \"water3\",\n        \"mineral\",\n        \"amorphous\",\n        \"water2\",\n        \"ditto\",\n        \"dragon\",\n        \"undiscovered\"\n    ].map((x)=>toID(x) + \" egggroup\"));\n    index.sort();\n    // manually rearrange\n    index[index.indexOf(\"grass type\")] = \"grass egggroup\";\n    index[index.indexOf(\"grass egggroup\")] = \"grass type\";\n    index[index.indexOf(\"fairy type\")] = \"fairy egggroup\";\n    index[index.indexOf(\"fairy egggroup\")] = \"fairy type\";\n    index[index.indexOf(\"flying type\")] = \"flying egggroup\";\n    index[index.indexOf(\"flying egggroup\")] = \"flying type\";\n    index[index.indexOf(\"dragon type\")] = \"dragon egggroup\";\n    index[index.indexOf(\"dragon egggroup\")] = \"dragon type\";\n    index[index.indexOf(\"bug type\")] = \"bug egggroup\";\n    index[index.indexOf(\"bug egggroup\")] = \"bug type\";\n    index[index.indexOf(\"psychic type\")] = \"psychic move\";\n    index[index.indexOf(\"psychic move\")] = \"psychic type\";\n    if (getID(BattlePokedex, \"ditto\")) {\n        index[index.indexOf(\"ditto pokemon\")] = \"ditto egggroup\";\n        index[index.indexOf(\"ditto egggroup\")] = \"ditto pokemon\";\n    }\n    $978dcbb073010154$var$BattleSearchIndex = index.map((x)=>{\n        let split = x.split(\" \");\n        if (split.length > 3) {\n            split[3] = Number(split[3]);\n            split[2] = index.indexOf(split[2] + \" \" + split[1]);\n        }\n        return split;\n    });\n    $978dcbb073010154$var$BattleSearchIndexOffset = $978dcbb073010154$var$BattleSearchIndex.map((entry, i)=>{\n        const id = entry[0];\n        let name = \"\";\n        switch(entry[1]){\n            case \"pokemon\":\n                name = getID(BattlePokedex, id).name ?? \"\";\n                break;\n            case \"move\":\n                name = getID(BattleMovedex, id).name ?? \"\";\n                break;\n            case \"item\":\n                name = getID(BattleItems, id).name ?? \"\";\n                break;\n            case \"ability\":\n                name = getID(BattleAbilities, id).name ?? \"\";\n                break;\n        }\n        let res = \"\";\n        let nonAlnum = 0;\n        for(let i = 0, j = 0; i < id.length; i++, j++){\n            while(!/[a-zA-Z0-9]/.test(name[j])){\n                j++;\n                nonAlnum++;\n            }\n            res += nonAlnum;\n        }\n        if (nonAlnum) return res;\n        return \"\";\n    });\n}\n/**\n\n/**\n * Backend for search UIs.\n */ class $978dcbb073010154$var$DexSearch {\n    static #_ = this.typeTable = {\n        pokemon: 1,\n        type: 2,\n        tier: 3,\n        move: 4,\n        item: 5,\n        ability: 6,\n        egggroup: 7,\n        category: 8,\n        article: 9\n    };\n    static #_1 = this.typeName = {\n        pokemon: \"Pok&eacute;mon\",\n        type: \"Type\",\n        tier: \"Tiers\",\n        move: \"Moves\",\n        item: \"Items\",\n        ability: \"Abilities\",\n        egggroup: \"Egg group\",\n        category: \"Category\",\n        article: \"Article\"\n    };\n    constructor(searchType = \"\", formatid = \"\", species = \"\"){\n        this.query = \"\";\n        this.typedSearch = null;\n        this.results = null;\n        this.exactMatch = false;\n        this.firstPokemonColumn = \"Number\";\n        /**\n   * Column to sort by. Default is `null`, a smart sort determined by how good\n   * things are according to the base filters, falling back to dex number (for\n   * Pokemon) and name (for everything else).\n   */ this.sortCol = null;\n        this.reverseSort = false;\n        /**\n   * Filters for the search result. Does not include the two base filters\n   * (format and species).\n   */ this.filters = null;\n        $978dcbb073010154$var$generateSearchIndex();\n        this.setType(searchType, formatid, species);\n    }\n    getTypedSearch(searchType, format = \"\", speciesOrSet) {\n        if (!searchType) return null;\n        switch(searchType){\n            case \"pokemon\":\n                return new $978dcbb073010154$var$BattlePokemonSearch(\"pokemon\", format, speciesOrSet);\n            case \"item\":\n                return new $978dcbb073010154$var$BattleItemSearch(\"item\", format, speciesOrSet);\n            case \"move\":\n                return new $978dcbb073010154$var$BattleMoveSearch(\"move\", format, speciesOrSet);\n            case \"ability\":\n                return new $978dcbb073010154$var$BattleAbilitySearch(\"ability\", format, speciesOrSet);\n            case \"type\":\n                return new $978dcbb073010154$var$BattleTypeSearch(\"type\", format, speciesOrSet);\n            case \"category\":\n                return new $978dcbb073010154$var$BattleCategorySearch(\"category\", format, speciesOrSet);\n        }\n        return null;\n    }\n    find(query) {\n        query = toID(query);\n        if (this.query === query && this.results) return false;\n        this.query = query;\n        if (!query) this.results = this.typedSearch?.getResults(this.filters, this.sortCol, this.reverseSort) || [];\n        else this.results = this.textSearch(query);\n        return true;\n    }\n    setType(searchType, format = \"\", speciesOrSet) {\n        // invalidate caches\n        this.results = null;\n        if (searchType !== this.typedSearch?.searchType) {\n            this.filters = null;\n            this.sortCol = null;\n        }\n        this.typedSearch = this.getTypedSearch(searchType, format, speciesOrSet);\n    }\n    addFilter(entry) {\n        if (!this.typedSearch) return false;\n        let [type] = entry;\n        if (this.typedSearch.searchType === \"pokemon\") {\n            if (type === this.sortCol) this.sortCol = null;\n            if (![\n                \"type\",\n                \"move\",\n                \"ability\",\n                \"egggroup\",\n                \"tier\"\n            ].includes(type)) return false;\n            if (type === \"move\") entry[1] = toID(entry[1]);\n            if (!this.filters) this.filters = [];\n            this.results = null;\n            for (const filter of this.filters){\n                if (filter[0] === type && filter[1] === entry[1]) return true;\n            }\n            this.filters.push(entry);\n            return true;\n        } else if (this.typedSearch.searchType === \"move\") {\n            if (type === this.sortCol) this.sortCol = null;\n            if (![\n                \"type\",\n                \"category\",\n                \"pokemon\"\n            ].includes(type)) return false;\n            if (type === \"pokemon\") entry[1] = toID(entry[1]);\n            if (!this.filters) this.filters = [];\n            this.filters.push(entry);\n            this.results = null;\n            return true;\n        }\n        return false;\n    }\n    removeFilter(entry) {\n        if (!this.filters) return false;\n        if (entry) {\n            const filterid = entry.join(\":\");\n            let deleted = null;\n            // delete specific filter\n            for(let i = 0; i < this.filters.length; i++)if (filterid === this.filters[i].join(\":\")) {\n                deleted = this.filters[i];\n                this.filters.splice(i, 1);\n                break;\n            }\n            if (!deleted) return false;\n        } else this.filters.pop();\n        if (!this.filters.length) this.filters = null;\n        this.results = null;\n        return true;\n    }\n    toggleSort(sortCol) {\n        if (this.sortCol === sortCol) {\n            if (!this.reverseSort) this.reverseSort = true;\n            else {\n                this.sortCol = null;\n                this.reverseSort = false;\n            }\n        } else {\n            this.sortCol = sortCol;\n            this.reverseSort = false;\n        }\n        this.results = null;\n    }\n    filterLabel(filterType) {\n        if (this.typedSearch && this.typedSearch.searchType !== filterType) return \"Filter\";\n        return null;\n    }\n    illegalLabel(id) {\n        return this.typedSearch?.illegalReasons?.[id] || null;\n    }\n    textSearch(query) {\n        query = toID(query);\n        this.exactMatch = false;\n        let searchType = this.typedSearch?.searchType || \"\";\n        // If searchType exists, we're searching mainly for results of that type.\n        // We'll still search for results of other types, but those results\n        // will only be used to filter results for that type.\n        let searchTypeIndex = searchType ? $978dcbb073010154$var$DexSearch.typeTable[searchType] : -1;\n        /** searching for \"Psychic type\" will make the type come up over the move */ let qFilterType = \"\";\n        if (query.slice(-4) === \"type\") {\n            if (query.slice(0, -4) in BattleTypeChart) {\n                query = query.slice(0, -4);\n                qFilterType = \"type\";\n            }\n        }\n        // i represents the location of the search index we're looking at\n        let i = $978dcbb073010154$var$DexSearch.getClosest(query);\n        this.exactMatch = $978dcbb073010154$var$BattleSearchIndex[i][0] === query;\n        // Even with output buffer buckets, we make multiple passes through\n        // the search index. searchPasses is a queue of which pass we're on:\n        // [passType, i, query]\n        // By doing an alias pass after the normal pass, we ensure that\n        // mid-word matches only display after start matches.\n        let passType = \"\";\n        let searchPasses = [\n            [\n                \"normal\",\n                i,\n                query\n            ]\n        ];\n        // For performance reasons, only do an alias pass if query is at\n        // least 2 chars long\n        if (query.length > 1) searchPasses.push([\n            \"alias\",\n            i,\n            query\n        ]);\n        // If there are no matches starting with query: Do a fuzzy match pass\n        // Fuzzy matches will still be shown after alias matches\n        if (!this.exactMatch && $978dcbb073010154$var$BattleSearchIndex[i][0].substr(0, query.length) !== query) {\n            // No results start with this. Do a fuzzy match pass.\n            let matchLength = query.length - 1;\n            if (!i) i++;\n            while(matchLength && $978dcbb073010154$var$BattleSearchIndex[i][0].substr(0, matchLength) !== query.substr(0, matchLength) && $978dcbb073010154$var$BattleSearchIndex[i - 1][0].substr(0, matchLength) !== query.substr(0, matchLength))matchLength--;\n            let matchQuery = query.substr(0, matchLength);\n            while(i >= 1 && $978dcbb073010154$var$BattleSearchIndex[i - 1][0].substr(0, matchLength) === matchQuery)i--;\n            searchPasses.push([\n                \"fuzzy\",\n                i,\n                \"\"\n            ]);\n        }\n        // We split the output buffers into 8 buckets.\n        // Bucket 0 is usually unused, and buckets 1-7 represent\n        // pokemon, types, moves, etc (see typeTable).\n        // When we're done, the buffers are concatenated together to form\n        // our results, with each buffer getting its own header, unlike\n        // multiple-pass results, which have no header.\n        // Notes:\n        // - if we have a searchType, that searchType's buffer will be on top\n        let bufs = [\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            []\n        ];\n        let topbufIndex = -1;\n        let count = 0;\n        let nearMatch = false;\n        /** [type, id, typeIndex] */ let instafilter = null;\n        let instafilterSort = [\n            0,\n            1,\n            2,\n            5,\n            4,\n            3,\n            6,\n            7,\n            8\n        ];\n        let illegal = this.typedSearch?.illegalReasons;\n        // We aren't actually looping through the entirety of the searchIndex\n        for(i = 0; i < $978dcbb073010154$var$BattleSearchIndex.length; i++){\n            if (!passType) {\n                let searchPass = searchPasses.shift();\n                if (!searchPass) break;\n                passType = searchPass[0];\n                i = searchPass[1];\n                query = searchPass[2];\n            }\n            let entry = $978dcbb073010154$var$BattleSearchIndex[i];\n            let id = entry[0];\n            let type = entry[1];\n            if (!id) break;\n            if (passType === \"fuzzy\") {\n                // fuzzy match pass; stop after 2 results\n                if (count >= 2) {\n                    passType = \"\";\n                    continue;\n                }\n                nearMatch = true;\n            } else if (passType === \"exact\") // exact pass; stop after 1 result\n            {\n                if (count >= 1) {\n                    passType = \"\";\n                    continue;\n                }\n            } else if (id.substr(0, query.length) !== query) {\n                // regular pass, time to move onto our next match\n                passType = \"\";\n                continue;\n            }\n            if (entry.length > 2) {\n                // alias entry\n                if (passType !== \"alias\") continue;\n            } else {\n                // normal entry\n                if (passType === \"alias\") continue;\n            }\n            let typeIndex = $978dcbb073010154$var$DexSearch.typeTable[type];\n            // For performance, with a query length of 1, we only fill the first bucket\n            if (query.length === 1 && typeIndex !== (searchType ? searchTypeIndex : 1)) continue;\n            // For pokemon queries, accept types/tier/abilities/moves/eggroups as filters\n            if (searchType === \"pokemon\" && (typeIndex === 5 || typeIndex > 7)) continue;\n            // For move queries, accept types/categories as filters\n            if (searchType === \"move\" && (typeIndex !== 8 && typeIndex > 4 || typeIndex === 3)) continue;\n            // For move queries in the teambuilder, don't accept pokemon as filters\n            if (searchType === \"move\" && illegal && typeIndex === 1) continue;\n            // For ability/item queries, don't accept anything else as a filter\n            if ((searchType === \"ability\" || searchType === \"item\") && typeIndex !== searchTypeIndex) continue;\n            // Query was a type name followed 'type'; only show types\n            if (qFilterType === \"type\" && typeIndex !== 2) continue;\n            // hardcode cases of duplicate non-consecutive aliases\n            if ((id === \"megax\" || id === \"megay\") && \"mega\".startsWith(query)) continue;\n            let matchStart = 0;\n            let matchEnd = 0;\n            if (passType === \"alias\") {\n                // alias entry\n                // [aliasid, type, originalid, matchStart, originalindex]\n                matchStart = entry[3];\n                let originalIndex = entry[2];\n                if (matchStart) {\n                    matchEnd = matchStart + query.length;\n                    matchStart += ($978dcbb073010154$var$BattleSearchIndexOffset[originalIndex][matchStart] || \"0\").charCodeAt(0) - 48;\n                    matchEnd += ($978dcbb073010154$var$BattleSearchIndexOffset[originalIndex][matchEnd - 1] || \"0\").charCodeAt(0) - 48;\n                }\n                id = $978dcbb073010154$var$BattleSearchIndex[originalIndex][0];\n            } else {\n                matchEnd = query.length;\n                if (matchEnd) matchEnd += ($978dcbb073010154$var$BattleSearchIndexOffset[i][matchEnd - 1] || \"0\").charCodeAt(0) - 48;\n            }\n            if (searchType && searchTypeIndex !== typeIndex) // This is a filter, set it as an instafilter candidate\n            {\n                if (!instafilter || instafilterSort[typeIndex] < instafilterSort[instafilter[2]]) instafilter = [\n                    type,\n                    id,\n                    typeIndex\n                ];\n            }\n            // show types above Arceus formes\n            if (topbufIndex < 0 && searchTypeIndex < 2 && passType === \"alias\" && !bufs[1].length && bufs[2].length) topbufIndex = 2;\n            if (illegal && typeIndex === searchTypeIndex) {\n                // Always show illegal results under legal results.\n                // This is done by putting legal results (and the type header)\n                // in bucket 0, and illegal results in the searchType's bucket.\n                // searchType buckets are always on top (but under bucket 0), so\n                // illegal results will be seamlessly right under legal results.\n                if (!bufs[typeIndex].length && !bufs[0].length) bufs[0] = [\n                    [\n                        \"header\",\n                        $978dcbb073010154$var$DexSearch.typeName[type]\n                    ]\n                ];\n                if (!(id in illegal)) typeIndex = 0;\n            } else if (!bufs[typeIndex].length) bufs[typeIndex] = [\n                [\n                    \"header\",\n                    $978dcbb073010154$var$DexSearch.typeName[type]\n                ]\n            ];\n            // don't match duplicate aliases\n            let curBufLength = passType === \"alias\" && bufs[typeIndex].length;\n            if (curBufLength && bufs[typeIndex][curBufLength - 1][1] === id) continue;\n            bufs[typeIndex].push([\n                type,\n                id,\n                matchStart,\n                matchEnd\n            ]);\n            count++;\n        }\n        let topbuf = [];\n        if (nearMatch) topbuf = [\n            [\n                \"html\",\n                `<em>No exact match found. The closest matches alphabetically are:</em>`\n            ]\n        ];\n        if (topbufIndex >= 0) {\n            topbuf = topbuf.concat(bufs[topbufIndex]);\n            bufs[topbufIndex] = [];\n        }\n        if (searchTypeIndex >= 0) {\n            topbuf = topbuf.concat(bufs[0]);\n            topbuf = topbuf.concat(bufs[searchTypeIndex]);\n            bufs[searchTypeIndex] = [];\n            bufs[0] = [];\n        }\n        if (instafilter && count < 20) // Result count is less than 20, so we can instafilter\n        bufs.push(this.instafilter(searchType, instafilter[0], instafilter[1]));\n        this.results = Array.prototype.concat.apply(topbuf, bufs);\n        return this.results ?? [];\n    }\n    instafilter(searchType, fType, fId) {\n        let buf = [];\n        let illegalBuf = [];\n        let illegal = this.typedSearch?.illegalReasons;\n        if (searchType === \"pokemon\") switch(fType){\n            case \"type\":\n                let type = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${type}-type Pok&eacute;mon`\n                ]);\n                for(let id in BattlePokedex){\n                    if (!BattlePokedex[id].types) continue;\n                    if (BattlePokedex[id].types.includes(type)) (illegal && id in illegal ? illegalBuf : buf).push([\n                        \"pokemon\",\n                        id\n                    ]);\n                }\n                break;\n            case \"ability\":\n                let ability = getID(BattleAbilities, fId).name;\n                buf.push([\n                    \"header\",\n                    `${ability} Pok&eacute;mon`\n                ]);\n                for(let id in BattlePokedex){\n                    if (!BattlePokedex[id].abilities) continue;\n                    if ($978dcbb073010154$var$hasAbility(BattlePokedex[id], ability)) (illegal && id in illegal ? illegalBuf : buf).push([\n                        \"pokemon\",\n                        id\n                    ]);\n                }\n                break;\n        }\n        else if (searchType === \"move\") switch(fType){\n            case \"type\":\n                let type1 = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${type1}-type moves`\n                ]);\n                for(let id in BattleMovedex)if (BattleMovedex[id].type === type1) (illegal && id in illegal ? illegalBuf : buf).push([\n                    \"move\",\n                    id\n                ]);\n                break;\n            case \"category\":\n                let category = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${category} moves`\n                ]);\n                for(let id in BattleMovedex)if (BattleMovedex[id].category === category) (illegal && id in illegal ? illegalBuf : buf).push([\n                    \"move\",\n                    id\n                ]);\n                break;\n        }\n        return [\n            ...buf,\n            ...illegalBuf\n        ];\n    }\n    static getClosest(query) {\n        // binary search through the index!\n        let left = 0;\n        let right = $978dcbb073010154$var$BattleSearchIndex.length - 1;\n        while(right > left){\n            let mid = Math.floor((right - left) / 2 + left);\n            if ($978dcbb073010154$var$BattleSearchIndex[mid][0] === query && (mid === 0 || $978dcbb073010154$var$BattleSearchIndex[mid - 1][0] !== query)) // that's us\n            return mid;\n            else if ($978dcbb073010154$var$BattleSearchIndex[mid][0] < query) left = mid + 1;\n            else right = mid - 1;\n        }\n        if (left >= $978dcbb073010154$var$BattleSearchIndex.length - 1) left = $978dcbb073010154$var$BattleSearchIndex.length - 1;\n        else if ($978dcbb073010154$var$BattleSearchIndex[left + 1][0] && $978dcbb073010154$var$BattleSearchIndex[left][0] < query) left++;\n        if (left && $978dcbb073010154$var$BattleSearchIndex[left - 1][0] === query) left--;\n        return left;\n    }\n}\nclass $978dcbb073010154$var$BattleTypedSearch {\n    constructor(searchType, format = \"\", speciesOrSet = \"\"){\n        /**\n   * `species` is the second of two base filters. It constrains results to\n   * things that species can use, and affects the default sort.\n   */ this.species = \"\";\n        /**\n   * `set` is a pseudo-base filter; it has minor effects on move sorting.\n   * (Abilities/items can affect what moves are sorted as usable.)\n   */ this.set = null;\n        /**\n   * Cached copy of what the results list would be with only base filters\n   * (i.e. with an empty `query` and `filters`)\n   */ this.baseResults = null;\n        /**\n   * Cached copy of all results not in `baseResults` - mostly in case a user\n   * is wondering why a specific result isn't showing up.\n   */ this.baseIllegalResults = null;\n        this.illegalReasons = null;\n        this.results = null;\n        this.sortRow = null;\n        this.searchType = searchType;\n        this.baseResults = null;\n        this.baseIllegalResults = null;\n        this.species = \"\";\n        this.set = null;\n        if (typeof speciesOrSet === \"string\") {\n            if (speciesOrSet) this.species = speciesOrSet;\n        } else {\n            this.set = speciesOrSet;\n            this.species = toID(this.set.species);\n        }\n        if (!searchType || !this.set) return;\n    }\n    getResults(filters, sortCol, reverseSort) {\n        if (sortCol === \"type\") return [\n            this.sortRow,\n            ...$978dcbb073010154$var$BattleTypeSearch.prototype.getDefaultResults.call(this)\n        ];\n        else if (sortCol === \"category\") return [\n            this.sortRow,\n            ...$978dcbb073010154$var$BattleCategorySearch.prototype.getDefaultResults.call(this)\n        ];\n        else if (sortCol === \"ability\") return [\n            this.sortRow,\n            ...$978dcbb073010154$var$BattleAbilitySearch.prototype.getDefaultResults.call(this)\n        ];\n        if (!this.baseResults) this.baseResults = this.getBaseResults();\n        if (!this.baseIllegalResults) {\n            const legalityFilter = {};\n            for (const [resultType, value] of this.baseResults)if (resultType === this.searchType) legalityFilter[value] = 1;\n            this.baseIllegalResults = [];\n            this.illegalReasons = {};\n            for(const id in this.getTable())if (!(id in legalityFilter)) {\n                this.baseIllegalResults.push([\n                    this.searchType,\n                    id\n                ]);\n                this.illegalReasons[id] = \"Illegal\";\n            }\n        }\n        let results;\n        let illegalResults;\n        if (filters) {\n            results = [];\n            illegalResults = [];\n            for (const result of this.baseResults)if (this.filter(result, filters)) {\n                if (results.length && result[0] === \"header\" && results[results.length - 1][0] === \"header\") results[results.length - 1] = result;\n                else results.push(result);\n            }\n            if (results.length && results[results.length - 1][0] === \"header\") results.pop();\n            for (const result of this.baseIllegalResults)if (this.filter(result, filters)) illegalResults.push(result);\n        } else {\n            results = [\n                ...this.baseResults\n            ];\n            illegalResults = null;\n        }\n        if (sortCol) {\n            results = results.filter(([rowType])=>rowType === this.searchType);\n            results = this.sort(results, sortCol, reverseSort);\n            if (illegalResults) {\n                illegalResults = illegalResults.filter(([rowType])=>rowType === this.searchType);\n                illegalResults = this.sort(illegalResults, sortCol, reverseSort);\n            }\n        }\n        if (this.sortRow) results = [\n            this.sortRow,\n            ...results\n        ];\n        if (illegalResults && illegalResults.length) results = [\n            ...results,\n            [\n                \"header\",\n                \"Illegal results\"\n            ],\n            ...illegalResults\n        ];\n        return results;\n    }\n}\nclass $978dcbb073010154$var$BattlePokemonSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"pokemon\") return true;\n        const poke = getID(BattlePokedex, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"type\":\n                if (poke.types.every((t)=>t != value)) return false;\n                break;\n            case \"move\":\n                if (!canLearn(poke.id, value)) return false;\n                break;\n            case \"ability\":\n                if (!$978dcbb073010154$var$hasAbility(poke, value)) return false;\n                break;\n            case \"egggroup\":\n                if (poke.eggGroups.every((t)=>t != value)) return false;\n                break;\n        }\n        return true;\n    }\n    getTable() {\n        return BattlePokedex;\n    }\n    getDefaultResults() {\n        let results = [];\n        for(let id in BattlePokedex){\n            switch(id){\n                case \"bulbasaur\":\n                    results.push([\n                        \"header\",\n                        \"Generation 1\"\n                    ]);\n                    break;\n                case \"chikorita\":\n                    results.push([\n                        \"header\",\n                        \"Generation 2\"\n                    ]);\n                    break;\n                case \"treecko\":\n                    results.push([\n                        \"header\",\n                        \"Generation 3\"\n                    ]);\n                    break;\n                case \"turtwig\":\n                    results.push([\n                        \"header\",\n                        \"Generation 4\"\n                    ]);\n                    break;\n                case \"victini\":\n                    results.push([\n                        \"header\",\n                        \"Generation 5\"\n                    ]);\n                    break;\n                case \"chespin\":\n                    results.push([\n                        \"header\",\n                        \"Generation 6\"\n                    ]);\n                    break;\n                case \"rowlet\":\n                    results.push([\n                        \"header\",\n                        \"Generation 7\"\n                    ]);\n                    break;\n                case \"grookey\":\n                    results.push([\n                        \"header\",\n                        \"Generation 8\"\n                    ]);\n                    break;\n                case \"sprigatito\":\n                    results.push([\n                        \"header\",\n                        \"Generation 9\"\n                    ]);\n                    break;\n                case \"missingno\":\n                    results.push([\n                        \"header\",\n                        \"Glitch\"\n                    ]);\n                    break;\n                case \"syclar\":\n                    results.push([\n                        \"header\",\n                        \"CAP\"\n                    ]);\n                    break;\n                case \"pikachucosplay\":\n                    continue;\n            }\n            results.push([\n                \"pokemon\",\n                id\n            ]);\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        if ([\n            \"hp\",\n            \"atk\",\n            \"def\",\n            \"spa\",\n            \"spd\",\n            \"spe\"\n        ].includes(sortCol)) return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const stat1 = getID(BattlePokedex, id1).baseStats[sortCol];\n            const stat2 = getID(BattlePokedex, id2).baseStats[sortCol];\n            return (stat2 - stat1) * sortOrder;\n        });\n        else if (sortCol === \"bst\") return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const base1 = getID(BattlePokedex, id1).baseStats;\n            const base2 = getID(BattlePokedex, id2).baseStats;\n            const bst1 = base1.hp + base1.atk + base1.def + base1.spa + base1.spd + base1.spe;\n            const bst2 = base2.hp + base2.atk + base2.def + base2.spa + base2.spd + base2.spe;\n            return (bst2 - bst1) * sortOrder;\n        });\n        else if (sortCol === \"name\") return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const name1 = id1;\n            const name2 = id2;\n            return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n        });\n        throw new Error(\"invalid sortcol\");\n    }\n    constructor(...args){\n        super(...args);\n        this.sortRow = [\n            \"sortpokemon\",\n            \"\"\n        ];\n    }\n}\nclass $978dcbb073010154$var$BattleAbilitySearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleAbilities;\n    }\n    getDefaultResults() {\n        const results = [];\n        for(let id in BattleAbilities)results.push([\n            \"ability\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"ability\") return true;\n        const ability = getID(BattleAbilities, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"pokemon\":\n                if (!$978dcbb073010154$var$hasAbility(getID(BattlePokedex, value), ability.name)) return false;\n                break;\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $978dcbb073010154$var$BattleItemSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleItems;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\n            \"header\",\n            \"Items\"\n        ]);\n        for(let id in BattleItems)results.push([\n            \"item\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $978dcbb073010154$var$BattleMoveSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleMovedex;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\n            \"header\",\n            \"Moves\"\n        ]);\n        for(let id in BattleMovedex)results.push([\n            \"move\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"move\") return true;\n        const move = getID(BattleMovedex, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"type\":\n                if (move.type !== value) return false;\n                break;\n            case \"category\":\n                if (move.category !== value) return false;\n                break;\n            case \"pokemon\":\n                if (!canLearn(value, move.id)) return false;\n                break;\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        switch(sortCol){\n            case \"power\":\n                let powerTable = {\n                    return: 102,\n                    frustration: 102,\n                    spitup: 300,\n                    trumpcard: 200,\n                    naturalgift: 80,\n                    grassknot: 120,\n                    lowkick: 120,\n                    gyroball: 150,\n                    electroball: 150,\n                    flail: 200,\n                    reversal: 200,\n                    present: 120,\n                    wringout: 120,\n                    crushgrip: 120,\n                    heatcrash: 120,\n                    heavyslam: 120,\n                    fling: 130,\n                    magnitude: 150,\n                    beatup: 24,\n                    punishment: 1020,\n                    psywave: 1250,\n                    nightshade: 1200,\n                    seismictoss: 1200,\n                    dragonrage: 1140,\n                    sonicboom: 1120,\n                    superfang: 1350,\n                    endeavor: 1399,\n                    sheercold: 1501,\n                    fissure: 1500,\n                    horndrill: 1500,\n                    guillotine: 1500\n                };\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let move1 = getID(BattleMovedex, id1);\n                    let move2 = getID(BattleMovedex, id2);\n                    let pow1 = move1.basePower || powerTable[id1] || (move1.category === \"Status\" ? -1 : 1400);\n                    let pow2 = move2.basePower || powerTable[id2] || (move2.category === \"Status\" ? -1 : 1400);\n                    return (pow2 - pow1) * sortOrder;\n                });\n            case \"accuracy\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let accuracy1 = getID(BattleMovedex, id1).accuracy || 0;\n                    let accuracy2 = getID(BattleMovedex, id2).accuracy || 0;\n                    if (accuracy1 === true) accuracy1 = 101;\n                    if (accuracy2 === true) accuracy2 = 101;\n                    return (accuracy2 - accuracy1) * sortOrder;\n                });\n            case \"pp\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let pp1 = getID(BattleMovedex, id1).pp || 0;\n                    let pp2 = getID(BattleMovedex, id2).pp || 0;\n                    return (pp2 - pp1) * sortOrder;\n                });\n            case \"name\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    const name1 = id1;\n                    const name2 = id2;\n                    return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n                });\n        }\n        throw new Error(\"invalid sortcol\");\n    }\n    constructor(...args){\n        super(...args);\n        this.sortRow = [\n            \"sortmove\",\n            \"\"\n        ];\n    }\n}\nclass $978dcbb073010154$var$BattleCategorySearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return {\n            physical: 1,\n            special: 1,\n            status: 1\n        };\n    }\n    getDefaultResults() {\n        return [\n            [\n                \"category\",\n                \"physical\"\n            ],\n            [\n                \"category\",\n                \"special\"\n            ],\n            [\n                \"category\",\n                \"status\"\n            ]\n        ];\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $978dcbb073010154$var$BattleTypeSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleTypeChart;\n    }\n    getDefaultResults() {\n        const results = [];\n        for(let id in BattleTypeChart)results.push([\n            \"type\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nwindow.DexSearch = $978dcbb073010154$var$DexSearch;\n\n\n//# sourceMappingURL=index.5f4c8433.js.map\n","/**\n * Search\n *\n * Code for searching for dex information\n *\n *\n * @author Guangcong Luo <guangcongluo@gmail.com>\n * @license MIT\n */\n\ntype ID = string;\ntype TypeName = string;\n\ntype SearchType =\n  | \"pokemon\"\n  | \"type\"\n  | \"tier\"\n  | \"move\"\n  | \"item\"\n  | \"ability\"\n  | \"egggroup\"\n  | \"category\";\n\ntype SearchRow =\n  | [SearchType, ID, number?, number?]\n  | [\"sortpokemon\" | \"sortmove\", \"\"]\n  | [\"header\" | \"html\", string];\n\ntype SearchFilter = [string, string];\n\n/**\n * PokemonSet can be sparse, in which case that entry should be\n * inferred from the rest of the set, according to sensible\n * defaults.\n */\ninterface PokemonSet {\n  species: string;\n}\n\n/** ID, SearchType, index (if alias), offset (if offset alias) */\nlet BattleSearchIndex: [ID, SearchType, number?, number?][] = [];\nlet BattleSearchIndexOffset: any;\ndeclare const BattleMovedex: any;\ndeclare const BattleAbilities: any;\ndeclare const BattleTypeChart: any;\ndeclare const BattlePokedex: any;\ndeclare const BattleItems: any;\ndeclare const Learnsets: any;\n\ndeclare function toID(id: string): ID;\ndeclare function getID(set: any, text: string): any;\ndeclare function canLearn(poke: ID, move: ID): boolean;\n\nfunction hasAbility(pokemon: any, ability: ID) {\n  for (let key in pokemon.abilities) {\n    if (toID(pokemon.abilities[key]) == toID(ability)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction generateSearchIndex() {\n  let index: string[] = [];\n\n  index = index.concat(Object.keys(BattlePokedex).map((x) => x + \" pokemon\"));\n  index = index.concat(Object.keys(BattleMovedex).map((x) => x + \" move\"));\n  index = index.concat(Object.keys(BattleItems).map((x) => x + \" item\"));\n  index = index.concat(Object.keys(BattleAbilities).map((x) => x + \" ability\"));\n  index = index.concat(\n    Object.keys(BattleTypeChart).map((x) => toID(x) + \" type\")\n  );\n  index = index.concat(\n    [\"physical\", \"special\", \"status\"].map((x) => toID(x) + \" category\")\n  );\n  index = index.concat(\n    [\n      \"monster\",\n      \"water1\",\n      \"bug\",\n      \"flying\",\n      \"field\",\n      \"fairy\",\n      \"grass\",\n      \"humanlike\",\n      \"water3\",\n      \"mineral\",\n      \"amorphous\",\n      \"water2\",\n      \"ditto\",\n      \"dragon\",\n      \"undiscovered\",\n    ].map((x) => toID(x) + \" egggroup\")\n  );\n\n  index.sort();\n\n  // manually rearrange\n  index[index.indexOf(\"grass type\")] = \"grass egggroup\";\n  index[index.indexOf(\"grass egggroup\")] = \"grass type\";\n\n  index[index.indexOf(\"fairy type\")] = \"fairy egggroup\";\n  index[index.indexOf(\"fairy egggroup\")] = \"fairy type\";\n\n  index[index.indexOf(\"flying type\")] = \"flying egggroup\";\n  index[index.indexOf(\"flying egggroup\")] = \"flying type\";\n\n  index[index.indexOf(\"dragon type\")] = \"dragon egggroup\";\n  index[index.indexOf(\"dragon egggroup\")] = \"dragon type\";\n\n  index[index.indexOf(\"bug type\")] = \"bug egggroup\";\n  index[index.indexOf(\"bug egggroup\")] = \"bug type\";\n\n  index[index.indexOf(\"psychic type\")] = \"psychic move\";\n  index[index.indexOf(\"psychic move\")] = \"psychic type\";\n\n  if (getID(BattlePokedex, \"ditto\")) {\n    index[index.indexOf(\"ditto pokemon\")] = \"ditto egggroup\";\n    index[index.indexOf(\"ditto egggroup\")] = \"ditto pokemon\";\n  }\n\n  BattleSearchIndex = index.map((x) => {\n    let split: [ID, SearchType, number?, number?] = x.split(\" \") as any;\n    if (split.length > 3) {\n      split[3] = Number(split[3]);\n      split[2] = index.indexOf(split[2] + \" \" + split[1]);\n    }\n    return split;\n  });\n\n  BattleSearchIndexOffset = BattleSearchIndex.map((entry, i) => {\n    const id = entry[0];\n    let name = \"\";\n    switch (entry[1]) {\n      case \"pokemon\":\n        name = getID(BattlePokedex, id).name ?? \"\";\n        break;\n      case \"move\":\n        name = getID(BattleMovedex, id).name ?? \"\";\n        break;\n      case \"item\":\n        name = getID(BattleItems, id).name ?? \"\";\n        break;\n      case \"ability\":\n        name = getID(BattleAbilities, id).name ?? \"\";\n        break;\n    }\n    let res = \"\";\n    let nonAlnum = 0;\n    for (let i = 0, j = 0; i < id.length; i++, j++) {\n      while (!/[a-zA-Z0-9]/.test(name[j])) {\n        j++;\n        nonAlnum++;\n      }\n      res += nonAlnum;\n    }\n    if (nonAlnum) return res;\n    return \"\";\n  });\n}\n/**\n\n/**\n * Backend for search UIs.\n */\nclass DexSearch {\n  query = \"\";\n\n  typedSearch: BattleTypedSearch<SearchType> | null = null;\n\n  results: SearchRow[] | null = null;\n  exactMatch = false;\n\n  static typeTable = {\n    pokemon: 1,\n    type: 2,\n    tier: 3,\n    move: 4,\n    item: 5,\n    ability: 6,\n    egggroup: 7,\n    category: 8,\n    article: 9,\n  };\n  static typeName = {\n    pokemon: \"Pok&eacute;mon\",\n    type: \"Type\",\n    tier: \"Tiers\",\n    move: \"Moves\",\n    item: \"Items\",\n    ability: \"Abilities\",\n    egggroup: \"Egg group\",\n    category: \"Category\",\n    article: \"Article\",\n  };\n  firstPokemonColumn: \"Tier\" | \"Number\" = \"Number\";\n\n  /**\n   * Column to sort by. Default is `null`, a smart sort determined by how good\n   * things are according to the base filters, falling back to dex number (for\n   * Pokemon) and name (for everything else).\n   */\n  sortCol: string | null = null;\n  reverseSort = false;\n\n  /**\n   * Filters for the search result. Does not include the two base filters\n   * (format and species).\n   */\n  filters: SearchFilter[] | null = null;\n\n  constructor(\n    searchType: SearchType | \"\" = \"\",\n    formatid = \"\" as ID,\n    species = \"\" as ID\n  ) {\n\t\tgenerateSearchIndex();\n    this.setType(searchType, formatid, species);\n  }\n\n  getTypedSearch(\n    searchType: SearchType | \"\",\n    format = \"\" as ID,\n    speciesOrSet: ID\n  ) {\n    if (!searchType) return null;\n    switch (searchType) {\n      case \"pokemon\":\n        return new BattlePokemonSearch(\"pokemon\", format, speciesOrSet);\n      case \"item\":\n        return new BattleItemSearch(\"item\", format, speciesOrSet);\n      case \"move\":\n        return new BattleMoveSearch(\"move\", format, speciesOrSet);\n      case \"ability\":\n        return new BattleAbilitySearch(\"ability\", format, speciesOrSet);\n      case \"type\":\n        return new BattleTypeSearch(\"type\", format, speciesOrSet);\n      case \"category\":\n        return new BattleCategorySearch(\"category\", format, speciesOrSet);\n    }\n    return null;\n  }\n\n  find(query: string) {\n    query = toID(query);\n    if (this.query === query && this.results) {\n      return false;\n    }\n    this.query = query;\n    if (!query) {\n      this.results =\n        this.typedSearch?.getResults(\n          this.filters,\n          this.sortCol,\n          this.reverseSort\n        ) || [];\n    } else {\n      this.results = this.textSearch(query);\n    }\n    return true;\n  }\n\n  setType(searchType: SearchType | \"\", format = \"\" as ID, speciesOrSet: ID) {\n    // invalidate caches\n    this.results = null;\n\n    if (searchType !== this.typedSearch?.searchType) {\n      this.filters = null;\n      this.sortCol = null;\n    }\n    this.typedSearch = this.getTypedSearch(searchType, format, speciesOrSet);\n  }\n\n  addFilter(entry: SearchFilter): boolean {\n    if (!this.typedSearch) return false;\n    let [type] = entry;\n    if (this.typedSearch.searchType === \"pokemon\") {\n      if (type === this.sortCol) this.sortCol = null;\n      if (![\"type\", \"move\", \"ability\", \"egggroup\", \"tier\"].includes(type))\n        return false;\n      if (type === \"move\") entry[1] = toID(entry[1]);\n      if (!this.filters) this.filters = [];\n      this.results = null;\n      for (const filter of this.filters) {\n        if (filter[0] === type && filter[1] === entry[1]) {\n          return true;\n        }\n      }\n      this.filters.push(entry);\n      return true;\n    } else if (this.typedSearch.searchType === \"move\") {\n      if (type === this.sortCol) this.sortCol = null;\n      if (![\"type\", \"category\", \"pokemon\"].includes(type)) return false;\n      if (type === \"pokemon\") entry[1] = toID(entry[1]);\n      if (!this.filters) this.filters = [];\n      this.filters.push(entry);\n      this.results = null;\n      return true;\n    }\n    return false;\n  }\n\n  removeFilter(entry?: SearchFilter): boolean {\n    if (!this.filters) return false;\n    if (entry) {\n      const filterid = entry.join(\":\");\n      let deleted: string[] | null = null;\n      // delete specific filter\n      for (let i = 0; i < this.filters.length; i++) {\n        if (filterid === this.filters[i].join(\":\")) {\n          deleted = this.filters[i];\n          this.filters.splice(i, 1);\n          break;\n        }\n      }\n      if (!deleted) return false;\n    } else {\n      this.filters.pop();\n    }\n    if (!this.filters.length) this.filters = null;\n    this.results = null;\n    return true;\n  }\n\n  toggleSort(sortCol: string) {\n    if (this.sortCol === sortCol) {\n      if (!this.reverseSort) {\n        this.reverseSort = true;\n      } else {\n        this.sortCol = null;\n        this.reverseSort = false;\n      }\n    } else {\n      this.sortCol = sortCol;\n      this.reverseSort = false;\n    }\n    this.results = null;\n  }\n\n  filterLabel(filterType: string) {\n    if (this.typedSearch && this.typedSearch.searchType !== filterType) {\n      return \"Filter\";\n    }\n    return null;\n  }\n  illegalLabel(id: ID) {\n    return this.typedSearch?.illegalReasons?.[id] || null;\n  }\n\n  textSearch(query: string): SearchRow[] {\n    query = toID(query);\n\n    this.exactMatch = false;\n    let searchType: SearchType | \"\" = this.typedSearch?.searchType || \"\";\n\n    // If searchType exists, we're searching mainly for results of that type.\n    // We'll still search for results of other types, but those results\n    // will only be used to filter results for that type.\n    let searchTypeIndex = searchType ? DexSearch.typeTable[searchType] : -1;\n\n    /** searching for \"Psychic type\" will make the type come up over the move */\n    let qFilterType: \"type\" | \"\" = \"\";\n    if (query.slice(-4) === \"type\") {\n      if (query.slice(0, -4) in BattleTypeChart) {\n        query = query.slice(0, -4);\n        qFilterType = \"type\";\n      }\n    }\n\n    // i represents the location of the search index we're looking at\n    let i = DexSearch.getClosest(query);\n    this.exactMatch = BattleSearchIndex[i][0] === query;\n\n    // Even with output buffer buckets, we make multiple passes through\n    // the search index. searchPasses is a queue of which pass we're on:\n    // [passType, i, query]\n\n    // By doing an alias pass after the normal pass, we ensure that\n    // mid-word matches only display after start matches.\n    let passType: SearchPassType | \"\" = \"\";\n    /**\n     * pass types:\n     * * '': time to pop the next pass off the searchPasses queue\n     * * 'normal': start at i and stop when results no longer start with query\n     * * 'alias': like normal, but output aliases instead of non-alias results\n     * * 'fuzzy': start at i and stop when you have two results\n     * * 'exact': like normal, but stop at i\n     */\n    type SearchPassType = \"normal\" | \"alias\" | \"fuzzy\" | \"exact\";\n    /**\n     * [passType, i, query]\n     *\n     * i = index of BattleSearchIndex to start from\n     *\n     * By doing an alias pass after the normal pass, we ensure that\n     * mid-word matches only display after start matches.\n     */\n    type SearchPass = [SearchPassType, number, string];\n    let searchPasses: SearchPass[] = [[\"normal\", i, query]];\n\n    // For performance reasons, only do an alias pass if query is at\n    // least 2 chars long\n    if (query.length > 1) searchPasses.push([\"alias\", i, query]);\n\n    // If there are no matches starting with query: Do a fuzzy match pass\n    // Fuzzy matches will still be shown after alias matches\n    if (\n      !this.exactMatch &&\n      BattleSearchIndex[i][0].substr(0, query.length) !== query\n    ) {\n      // No results start with this. Do a fuzzy match pass.\n      let matchLength = query.length - 1;\n      if (!i) i++;\n      while (\n        matchLength &&\n        BattleSearchIndex[i][0].substr(0, matchLength) !==\n          query.substr(0, matchLength) &&\n        BattleSearchIndex[i - 1][0].substr(0, matchLength) !==\n          query.substr(0, matchLength)\n      ) {\n        matchLength--;\n      }\n      let matchQuery = query.substr(0, matchLength);\n      while (\n        i >= 1 &&\n        BattleSearchIndex[i - 1][0].substr(0, matchLength) === matchQuery\n      )\n        i--;\n      searchPasses.push([\"fuzzy\", i, \"\"]);\n    }\n\n    // We split the output buffers into 8 buckets.\n    // Bucket 0 is usually unused, and buckets 1-7 represent\n    // pokemon, types, moves, etc (see typeTable).\n\n    // When we're done, the buffers are concatenated together to form\n    // our results, with each buffer getting its own header, unlike\n    // multiple-pass results, which have no header.\n\n    // Notes:\n    // - if we have a searchType, that searchType's buffer will be on top\n    let bufs: SearchRow[][] = [[], [], [], [], [], [], [], [], [], []];\n    let topbufIndex = -1;\n\n    let count = 0;\n    let nearMatch = false;\n\n    /** [type, id, typeIndex] */\n    let instafilter: [SearchType, ID, number] | null = null;\n    let instafilterSort = [0, 1, 2, 5, 4, 3, 6, 7, 8];\n    let illegal = this.typedSearch?.illegalReasons;\n\n    // We aren't actually looping through the entirety of the searchIndex\n    for (i = 0; i < BattleSearchIndex.length; i++) {\n      if (!passType) {\n        let searchPass = searchPasses.shift();\n        if (!searchPass) break;\n        passType = searchPass[0];\n        i = searchPass[1];\n        query = searchPass[2];\n      }\n\n      let entry = BattleSearchIndex[i];\n      let id = entry[0];\n      let type = entry[1];\n\n      if (!id) break;\n\n      if (passType === \"fuzzy\") {\n        // fuzzy match pass; stop after 2 results\n        if (count >= 2) {\n          passType = \"\";\n          continue;\n        }\n        nearMatch = true;\n      } else if (passType === \"exact\") {\n        // exact pass; stop after 1 result\n        if (count >= 1) {\n          passType = \"\";\n          continue;\n        }\n      } else if (id.substr(0, query.length) !== query) {\n        // regular pass, time to move onto our next match\n        passType = \"\";\n        continue;\n      }\n\n      if (entry.length > 2) {\n        // alias entry\n        if (passType !== \"alias\") continue;\n      } else {\n        // normal entry\n        if (passType === \"alias\") continue;\n      }\n\n      let typeIndex = DexSearch.typeTable[type];\n\n      // For performance, with a query length of 1, we only fill the first bucket\n      if (\n        query.length === 1 &&\n        typeIndex !== (searchType ? searchTypeIndex : 1)\n      )\n        continue;\n\n      // For pokemon queries, accept types/tier/abilities/moves/eggroups as filters\n      if (searchType === \"pokemon\" && (typeIndex === 5 || typeIndex > 7))\n        continue;\n      // For move queries, accept types/categories as filters\n      if (\n        searchType === \"move\" &&\n        ((typeIndex !== 8 && typeIndex > 4) || typeIndex === 3)\n      )\n        continue;\n      // For move queries in the teambuilder, don't accept pokemon as filters\n      if (searchType === \"move\" && illegal && typeIndex === 1) continue;\n      // For ability/item queries, don't accept anything else as a filter\n      if (\n        (searchType === \"ability\" || searchType === \"item\") &&\n        typeIndex !== searchTypeIndex\n      )\n        continue;\n      // Query was a type name followed 'type'; only show types\n      if (qFilterType === \"type\" && typeIndex !== 2) continue;\n      // hardcode cases of duplicate non-consecutive aliases\n      if ((id === \"megax\" || id === \"megay\") && \"mega\".startsWith(query))\n        continue;\n\n      let matchStart = 0;\n      let matchEnd = 0;\n      if (passType === \"alias\") {\n        // alias entry\n        // [aliasid, type, originalid, matchStart, originalindex]\n        matchStart = entry[3]!;\n        let originalIndex = entry[2]!;\n        if (matchStart) {\n          matchEnd = matchStart + query.length;\n          matchStart +=\n            (\n              BattleSearchIndexOffset[originalIndex][matchStart] || \"0\"\n            ).charCodeAt(0) - 48;\n          matchEnd +=\n            (\n              BattleSearchIndexOffset[originalIndex][matchEnd - 1] || \"0\"\n            ).charCodeAt(0) - 48;\n        }\n        id = BattleSearchIndex[originalIndex][0];\n      } else {\n        matchEnd = query.length;\n        if (matchEnd)\n          matchEnd +=\n            (BattleSearchIndexOffset[i][matchEnd - 1] || \"0\").charCodeAt(0) -\n            48;\n      }\n\n      if (searchType && searchTypeIndex !== typeIndex) {\n        // This is a filter, set it as an instafilter candidate\n        if (\n          !instafilter ||\n          instafilterSort[typeIndex] < instafilterSort[instafilter[2]]\n        ) {\n          instafilter = [type, id, typeIndex];\n        }\n      }\n\n      // show types above Arceus formes\n      if (\n        topbufIndex < 0 &&\n        searchTypeIndex < 2 &&\n        passType === \"alias\" &&\n        !bufs[1].length &&\n        bufs[2].length\n      ) {\n        topbufIndex = 2;\n      }\n\n      if (illegal && typeIndex === searchTypeIndex) {\n        // Always show illegal results under legal results.\n        // This is done by putting legal results (and the type header)\n        // in bucket 0, and illegal results in the searchType's bucket.\n        // searchType buckets are always on top (but under bucket 0), so\n        // illegal results will be seamlessly right under legal results.\n        if (!bufs[typeIndex].length && !bufs[0].length) {\n          bufs[0] = [[\"header\", DexSearch.typeName[type]]];\n        }\n        if (!(id in illegal)) typeIndex = 0;\n      } else {\n        if (!bufs[typeIndex].length) {\n          bufs[typeIndex] = [[\"header\", DexSearch.typeName[type]]];\n        }\n      }\n\n      // don't match duplicate aliases\n      let curBufLength = passType === \"alias\" && bufs[typeIndex].length;\n      if (curBufLength && bufs[typeIndex][curBufLength - 1][1] === id) continue;\n\n      bufs[typeIndex].push([type, id, matchStart, matchEnd]);\n\n      count++;\n    }\n\n    let topbuf: SearchRow[] = [];\n    if (nearMatch) {\n      topbuf = [\n        [\n          \"html\",\n          `<em>No exact match found. The closest matches alphabetically are:</em>`,\n        ],\n      ];\n    }\n    if (topbufIndex >= 0) {\n      topbuf = topbuf.concat(bufs[topbufIndex]);\n      bufs[topbufIndex] = [];\n    }\n    if (searchTypeIndex >= 0) {\n      topbuf = topbuf.concat(bufs[0]);\n      topbuf = topbuf.concat(bufs[searchTypeIndex]);\n      bufs[searchTypeIndex] = [];\n      bufs[0] = [];\n    }\n\n    if (instafilter && count < 20) {\n      // Result count is less than 20, so we can instafilter\n      bufs.push(this.instafilter(searchType, instafilter[0], instafilter[1]));\n    }\n\n    this.results = Array.prototype.concat.apply(topbuf, bufs);\n    return this.results ?? [];\n  }\n  private instafilter(\n    searchType: SearchType | \"\",\n    fType: SearchType,\n    fId: ID\n  ): SearchRow[] {\n    let buf: SearchRow[] = [];\n    let illegalBuf: SearchRow[] = [];\n    let illegal = this.typedSearch?.illegalReasons;\n    if (searchType === \"pokemon\") {\n      switch (fType) {\n        case \"type\":\n          let type = (fId.charAt(0).toUpperCase() + fId.slice(1)) as TypeName;\n          buf.push([\"header\", `${type}-type Pok&eacute;mon`]);\n          for (let id in BattlePokedex) {\n            if (!BattlePokedex[id].types) continue;\n            if (BattlePokedex[id].types.includes(type)) {\n              (illegal && id in illegal ? illegalBuf : buf).push([\n                \"pokemon\",\n                id as ID,\n              ]);\n            }\n          }\n          break;\n        case \"ability\":\n          let ability = getID(BattleAbilities, fId).name;\n          buf.push([\"header\", `${ability} Pok&eacute;mon`]);\n          for (let id in BattlePokedex) {\n            if (!BattlePokedex[id].abilities) continue;\n            if (hasAbility(BattlePokedex[id], ability)) {\n              (illegal && id in illegal ? illegalBuf : buf).push([\n                \"pokemon\",\n                id as ID,\n              ]);\n            }\n          }\n          break;\n      }\n    } else if (searchType === \"move\") {\n      switch (fType) {\n        case \"type\":\n          let type = fId.charAt(0).toUpperCase() + fId.slice(1);\n          buf.push([\"header\", `${type}-type moves`]);\n          for (let id in BattleMovedex) {\n            if (BattleMovedex[id].type === type) {\n              (illegal && id in illegal ? illegalBuf : buf).push([\n                \"move\",\n                id as ID,\n              ]);\n            }\n          }\n          break;\n        case \"category\":\n          let category = fId.charAt(0).toUpperCase() + fId.slice(1);\n          buf.push([\"header\", `${category} moves`]);\n          for (let id in BattleMovedex) {\n            if (BattleMovedex[id].category === category) {\n              (illegal && id in illegal ? illegalBuf : buf).push([\n                \"move\",\n                id as ID,\n              ]);\n            }\n          }\n          break;\n      }\n    }\n    return [...buf, ...illegalBuf];\n  }\n\n  static getClosest(query: string) {\n    // binary search through the index!\n    let left = 0;\n    let right = BattleSearchIndex.length - 1;\n    while (right > left) {\n      let mid = Math.floor((right - left) / 2 + left);\n      if (\n        BattleSearchIndex[mid][0] === query &&\n        (mid === 0 || BattleSearchIndex[mid - 1][0] !== query)\n      ) {\n        // that's us\n        return mid;\n      } else if (BattleSearchIndex[mid][0] < query) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    if (left >= BattleSearchIndex.length - 1)\n      left = BattleSearchIndex.length - 1;\n    else if (\n      BattleSearchIndex[left + 1][0] &&\n      BattleSearchIndex[left][0] < query\n    )\n      left++;\n    if (left && BattleSearchIndex[left - 1][0] === query) left--;\n    return left;\n  }\n}\n\nabstract class BattleTypedSearch<T extends SearchType> {\n  searchType: T;\n  /**\n   * `species` is the second of two base filters. It constrains results to\n   * things that species can use, and affects the default sort.\n   */\n  species = \"\" as ID;\n  /**\n   * `set` is a pseudo-base filter; it has minor effects on move sorting.\n   * (Abilities/items can affect what moves are sorted as usable.)\n   */\n  set: PokemonSet | null = null;\n\n  /**\n   * Cached copy of what the results list would be with only base filters\n   * (i.e. with an empty `query` and `filters`)\n   */\n  baseResults: SearchRow[] | null = null;\n  /**\n   * Cached copy of all results not in `baseResults` - mostly in case a user\n   * is wondering why a specific result isn't showing up.\n   */\n  baseIllegalResults: SearchRow[] | null = null;\n  illegalReasons: { [id: string]: string } | null = null;\n  results: SearchRow[] | null = null;\n\n  protected readonly sortRow: SearchRow | null = null;\n\n  constructor(\n    searchType: T,\n    format = \"\" as ID,\n    speciesOrSet: ID | PokemonSet = \"\" as ID\n  ) {\n    this.searchType = searchType;\n\n    this.baseResults = null;\n    this.baseIllegalResults = null;\n\n    this.species = \"\" as ID;\n    this.set = null;\n    if (typeof speciesOrSet === \"string\") {\n      if (speciesOrSet) this.species = speciesOrSet;\n    } else {\n      this.set = speciesOrSet as PokemonSet;\n      this.species = toID(this.set.species);\n    }\n    if (!searchType || !this.set) return;\n  }\n  getResults(\n    filters?: SearchFilter[] | null,\n    sortCol?: string | null,\n    reverseSort?: boolean\n  ): SearchRow[] {\n    if (sortCol === \"type\") {\n      return [\n        this.sortRow!,\n        ...BattleTypeSearch.prototype.getDefaultResults.call(this),\n      ];\n    } else if (sortCol === \"category\") {\n      return [\n        this.sortRow!,\n        ...BattleCategorySearch.prototype.getDefaultResults.call(this),\n      ];\n    } else if (sortCol === \"ability\") {\n      return [\n        this.sortRow!,\n        ...BattleAbilitySearch.prototype.getDefaultResults.call(this),\n      ];\n    }\n\n    if (!this.baseResults) {\n      this.baseResults = this.getBaseResults();\n    }\n\n    if (!this.baseIllegalResults) {\n      const legalityFilter: { [id: string]: 1 } = {};\n      for (const [resultType, value] of this.baseResults) {\n        if (resultType === this.searchType) legalityFilter[value] = 1;\n      }\n      this.baseIllegalResults = [];\n      this.illegalReasons = {};\n\n      for (const id in this.getTable()) {\n        if (!(id in legalityFilter)) {\n          this.baseIllegalResults.push([this.searchType, id as ID]);\n          this.illegalReasons[id] = \"Illegal\";\n        }\n      }\n    }\n\n    let results: SearchRow[];\n    let illegalResults: SearchRow[] | null;\n\n    if (filters) {\n      results = [];\n      illegalResults = [];\n      for (const result of this.baseResults) {\n        if (this.filter(result, filters)) {\n          if (\n            results.length &&\n            result[0] === \"header\" &&\n            results[results.length - 1][0] === \"header\"\n          ) {\n            results[results.length - 1] = result;\n          } else {\n            results.push(result);\n          }\n        }\n      }\n      if (results.length && results[results.length - 1][0] === \"header\") {\n        results.pop();\n      }\n      for (const result of this.baseIllegalResults) {\n        if (this.filter(result, filters)) {\n          illegalResults.push(result);\n        }\n      }\n    } else {\n      results = [...this.baseResults];\n      illegalResults = null;\n    }\n\n    if (sortCol) {\n      results = results.filter(([rowType]) => rowType === this.searchType);\n      results = this.sort(results, sortCol, reverseSort);\n      if (illegalResults) {\n        illegalResults = illegalResults.filter(\n          ([rowType]) => rowType === this.searchType\n        );\n        illegalResults = this.sort(illegalResults, sortCol, reverseSort);\n      }\n    }\n\n    if (this.sortRow) {\n      results = [this.sortRow, ...results];\n    }\n    if (illegalResults && illegalResults.length) {\n      results = [...results, [\"header\", \"Illegal results\"], ...illegalResults];\n    }\n    return results;\n  }\n\n  abstract getTable(): { [id: string]: any };\n  abstract getDefaultResults(): SearchRow[];\n  abstract getBaseResults(): SearchRow[];\n  abstract filter(input: SearchRow, filters: string[][]): boolean;\n  abstract sort(\n    input: SearchRow[],\n    sortCol: string,\n    reverseSort?: boolean\n  ): SearchRow[];\n}\n\nclass BattlePokemonSearch extends BattleTypedSearch<\"pokemon\"> {\n  filter(row: SearchRow, filters: string[][]): boolean {\n    if (!filters) return true;\n    if (row[0] !== \"pokemon\") return true;\n    const poke = getID(BattlePokedex, row[1]);\n    for (const [filterType, value] of filters) {\n      switch (filterType) {\n        case \"type\":\n          if (poke.types.every((t) => t != value)) return false;\n          break;\n        case \"move\":\n          if (!canLearn(poke.id, value)) return false;\n          break;\n        case \"ability\":\n          if (!hasAbility(poke, value)) return false;\n          break;\n        case \"egggroup\":\n          if (poke.eggGroups.every((t) => t != value)) return false;\n          break;\n      }\n    }\n    return true;\n  }\n  sortRow: SearchRow = [\"sortpokemon\", \"\"];\n  getTable() {\n    return BattlePokedex;\n  }\n  getDefaultResults(): SearchRow[] {\n    let results: SearchRow[] = [];\n    for (let id in BattlePokedex) {\n      switch (id) {\n        case \"bulbasaur\":\n          results.push([\"header\", \"Generation 1\"]);\n          break;\n        case \"chikorita\":\n          results.push([\"header\", \"Generation 2\"]);\n          break;\n        case \"treecko\":\n          results.push([\"header\", \"Generation 3\"]);\n          break;\n        case \"turtwig\":\n          results.push([\"header\", \"Generation 4\"]);\n          break;\n        case \"victini\":\n          results.push([\"header\", \"Generation 5\"]);\n          break;\n        case \"chespin\":\n          results.push([\"header\", \"Generation 6\"]);\n          break;\n        case \"rowlet\":\n          results.push([\"header\", \"Generation 7\"]);\n          break;\n        case \"grookey\":\n          results.push([\"header\", \"Generation 8\"]);\n          break;\n        case \"sprigatito\":\n          results.push([\"header\", \"Generation 9\"]);\n          break;\n        case \"missingno\":\n          results.push([\"header\", \"Glitch\"]);\n          break;\n        case \"syclar\":\n          results.push([\"header\", \"CAP\"]);\n          break;\n        case \"pikachucosplay\":\n          continue;\n      }\n      results.push([\"pokemon\", id as ID]);\n    }\n    return results;\n  }\n  getBaseResults(): SearchRow[] {\n    return this.getDefaultResults();\n  }\n  sort(results: SearchRow[], sortCol: string, reverseSort?: boolean) {\n    const sortOrder = reverseSort ? -1 : 1;\n    if ([\"hp\", \"atk\", \"def\", \"spa\", \"spd\", \"spe\"].includes(sortCol)) {\n      return results.sort(([rowType1, id1], [rowType2, id2]) => {\n        const stat1 = getID(BattlePokedex, id1).baseStats[sortCol];\n        const stat2 = getID(BattlePokedex, id2).baseStats[sortCol];\n        return (stat2 - stat1) * sortOrder;\n      });\n    } else if (sortCol === \"bst\") {\n      return results.sort(([rowType1, id1], [rowType2, id2]) => {\n        const base1 = getID(BattlePokedex, id1).baseStats;\n        const base2 = getID(BattlePokedex, id2).baseStats;\n        const bst1 =\n          base1.hp + base1.atk + base1.def + base1.spa + base1.spd + base1.spe;\n        const bst2 =\n          base2.hp + base2.atk + base2.def + base2.spa + base2.spd + base2.spe;\n        return (bst2 - bst1) * sortOrder;\n      });\n    } else if (sortCol === \"name\") {\n      return results.sort(([rowType1, id1], [rowType2, id2]) => {\n        const name1 = id1;\n        const name2 = id2;\n        return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n      });\n    }\n    throw new Error(\"invalid sortcol\");\n  }\n}\n\nclass BattleAbilitySearch extends BattleTypedSearch<\"ability\"> {\n  getTable() {\n    return BattleAbilities;\n  }\n  getDefaultResults(): SearchRow[] {\n    const results: SearchRow[] = [];\n    for (let id in BattleAbilities) {\n      results.push([\"ability\", id as ID]);\n    }\n    return results;\n  }\n  getBaseResults() {\n    return this.getDefaultResults();\n  }\n  filter(row: SearchRow, filters: string[][]) {\n    if (!filters) return true;\n    if (row[0] !== \"ability\") return true;\n    const ability = getID(BattleAbilities, row[1]);\n    for (const [filterType, value] of filters) {\n      switch (filterType) {\n        case \"pokemon\":\n          if (!hasAbility(getID(BattlePokedex, value), ability.name))\n            return false;\n          break;\n      }\n    }\n    return true;\n  }\n  sort(\n    results: SearchRow[],\n    sortCol: string | null,\n    reverseSort?: boolean\n  ): SearchRow[] {\n    throw new Error(\"invalid sortcol\");\n  }\n}\n\nclass BattleItemSearch extends BattleTypedSearch<\"item\"> {\n  getTable() {\n    return BattleItems;\n  }\n  getDefaultResults(): SearchRow[] {\n    let results: SearchRow[] = [];\n    results.push([\"header\", \"Items\"]);\n    for (let id in BattleItems) {\n      results.push([\"item\", id as ID]);\n    }\n    return results;\n  }\n\n  getBaseResults(): SearchRow[] {\n    return this.getDefaultResults();\n  }\n  filter(row: SearchRow, filters: string[][]): boolean {\n    throw new Error(\"invalid filter\");\n  }\n  sort(\n    results: SearchRow[],\n    sortCol: string | null,\n    reverseSort?: boolean\n  ): SearchRow[] {\n    throw new Error(\"invalid sortcol\");\n  }\n}\n\nclass BattleMoveSearch extends BattleTypedSearch<\"move\"> {\n  sortRow: SearchRow = [\"sortmove\", \"\"];\n  getTable() {\n    return BattleMovedex;\n  }\n  getDefaultResults(): SearchRow[] {\n    let results: SearchRow[] = [];\n    results.push([\"header\", \"Moves\"]);\n    for (let id in BattleMovedex) {\n      results.push([\"move\", id as ID]);\n    }\n    return results;\n  }\n\n  getBaseResults() {\n    return this.getDefaultResults();\n  }\n\n  filter(row: SearchRow, filters: string[][]) {\n    if (!filters) return true;\n    if (row[0] !== \"move\") return true;\n    const move = getID(BattleMovedex, row[1]);\n    for (const [filterType, value] of filters) {\n      switch (filterType) {\n        case \"type\":\n          if (move.type !== value) return false;\n          break;\n        case \"category\":\n          if (move.category !== value) return false;\n          break;\n        case \"pokemon\":\n          if (!canLearn(value as ID, move.id)) return false;\n          break;\n      }\n    }\n    return true;\n  }\n  sort(\n    results: SearchRow[],\n    sortCol: string,\n    reverseSort?: boolean\n  ): SearchRow[] {\n    const sortOrder = reverseSort ? -1 : 1;\n    switch (sortCol) {\n      case \"power\":\n        let powerTable: { [id: string]: number | undefined } = {\n          return: 102,\n          frustration: 102,\n          spitup: 300,\n          trumpcard: 200,\n          naturalgift: 80,\n          grassknot: 120,\n          lowkick: 120,\n          gyroball: 150,\n          electroball: 150,\n          flail: 200,\n          reversal: 200,\n          present: 120,\n          wringout: 120,\n          crushgrip: 120,\n          heatcrash: 120,\n          heavyslam: 120,\n          fling: 130,\n          magnitude: 150,\n          beatup: 24,\n          punishment: 1020,\n          psywave: 1250,\n          nightshade: 1200,\n          seismictoss: 1200,\n          dragonrage: 1140,\n          sonicboom: 1120,\n          superfang: 1350,\n          endeavor: 1399,\n          sheercold: 1501,\n          fissure: 1500,\n          horndrill: 1500,\n          guillotine: 1500,\n        };\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\n          let move1 = getID(BattleMovedex, id1);\n          let move2 = getID(BattleMovedex, id2);\n          let pow1 =\n            move1.basePower ||\n            powerTable[id1] ||\n            (move1.category === \"Status\" ? -1 : 1400);\n          let pow2 =\n            move2.basePower ||\n            powerTable[id2] ||\n            (move2.category === \"Status\" ? -1 : 1400);\n          return (pow2 - pow1) * sortOrder;\n        });\n      case \"accuracy\":\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\n          let accuracy1 = getID(BattleMovedex, id1).accuracy || 0;\n          let accuracy2 = getID(BattleMovedex, id2).accuracy || 0;\n          if (accuracy1 === true) accuracy1 = 101;\n          if (accuracy2 === true) accuracy2 = 101;\n          return (accuracy2 - accuracy1) * sortOrder;\n        });\n      case \"pp\":\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\n          let pp1 = getID(BattleMovedex, id1).pp || 0;\n          let pp2 = getID(BattleMovedex, id2).pp || 0;\n          return (pp2 - pp1) * sortOrder;\n        });\n      case \"name\":\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\n          const name1 = id1;\n          const name2 = id2;\n          return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n        });\n    }\n    throw new Error(\"invalid sortcol\");\n  }\n}\n\nclass BattleCategorySearch extends BattleTypedSearch<\"category\"> {\n  getTable() {\n    return { physical: 1, special: 1, status: 1 };\n  }\n  getDefaultResults(): SearchRow[] {\n    return [\n      [\"category\", \"physical\" as ID],\n      [\"category\", \"special\" as ID],\n      [\"category\", \"status\" as ID],\n    ];\n  }\n  getBaseResults() {\n    return this.getDefaultResults();\n  }\n  filter(row: SearchRow, filters: string[][]): boolean {\n    throw new Error(\"invalid filter\");\n  }\n  sort(\n    results: SearchRow[],\n    sortCol: string | null,\n    reverseSort?: boolean\n  ): SearchRow[] {\n    throw new Error(\"invalid sortcol\");\n  }\n}\n\nclass BattleTypeSearch extends BattleTypedSearch<\"type\"> {\n  getTable() {\n    return BattleTypeChart;\n  }\n  getDefaultResults(): SearchRow[] {\n    const results: SearchRow[] = [];\n    for (let id in BattleTypeChart) {\n      results.push([\"type\", id as ID]);\n    }\n    return results;\n  }\n  getBaseResults() {\n    return this.getDefaultResults();\n  }\n  filter(row: SearchRow, filters: string[][]): boolean {\n    throw new Error(\"invalid filter\");\n  }\n  sort(\n    results: SearchRow[],\n    sortCol: string | null,\n    reverseSort?: boolean\n  ): SearchRow[] {\n    throw new Error(\"invalid sortcol\");\n  }\n}\n\n\nexport {}\ndeclare global {\n  interface Window {\n    DexSearch: typeof DexSearch;\n  }\n}\nwindow.DexSearch = DexSearch;\n"],"names":["$978dcbb073010154$var$BattleSearchIndexOffset","$978dcbb073010154$var$BattleSearchIndex","$978dcbb073010154$var$hasAbility","pokemon","ability","key","abilities","toID","$978dcbb073010154$var$DexSearch","_","typeTable","type","tier","move","item","egggroup","category","article","_1","typeName","constructor","searchType","formatid","species","index","query","typedSearch","results","exactMatch","firstPokemonColumn","sortCol","reverseSort","filters","concat","Object","keys","BattlePokedex","map","x","BattleMovedex","BattleItems","BattleAbilities","BattleTypeChart","sort","indexOf","getID","split","length","Number","entry","i","id","name","res","nonAlnum","j","test","setType","getTypedSearch","format","speciesOrSet","$978dcbb073010154$var$BattlePokemonSearch","$978dcbb073010154$var$BattleItemSearch","$978dcbb073010154$var$BattleMoveSearch","$978dcbb073010154$var$BattleAbilitySearch","$978dcbb073010154$var$BattleTypeSearch","$978dcbb073010154$var$BattleCategorySearch","find","textSearch","getResults","addFilter","includes","filter","push","removeFilter","filterid","join","deleted","splice","pop","toggleSort","filterLabel","filterType","illegalLabel","illegalReasons","searchTypeIndex","qFilterType","slice","getClosest","passType","searchPasses","substr","matchLength","matchQuery","bufs","topbufIndex","count","nearMatch","instafilter","instafilterSort","illegal","searchPass","shift","typeIndex","startsWith","matchStart","matchEnd","originalIndex","charCodeAt","curBufLength","topbuf","Array","prototype","apply","fType","fId","buf","illegalBuf","charAt","toUpperCase","types","type1","left","right","mid","Math","floor","$978dcbb073010154$var$BattleTypedSearch","set","baseResults","baseIllegalResults","sortRow","illegalResults","getDefaultResults","call","getBaseResults","legalityFilter","resultType","value","getTable","result","rowType","row","poke","every","t","canLearn","eggGroups","sortOrder","rowType1","id1","rowType2","id2","stat1","baseStats","stat2","base1","base2","bst1","hp","atk","def","spa","spd","spe","bst2","name1","Error","args","powerTable","return","frustration","spitup","trumpcard","naturalgift","grassknot","lowkick","gyroball","electroball","flail","reversal","present","wringout","crushgrip","heatcrash","heavyslam","fling","magnitude","beatup","punishment","psywave","nightshade","seismictoss","dragonrage","sonicboom","superfang","endeavor","sheercold","fissure","horndrill","guillotine","move1","move2","pow1","basePower","pow2","accuracy1","accuracy","accuracy2","pp1","pp","pp2","physical","special","status","window","DexSearch"],"version":3,"file":"index.5f4c8433.js.map"}